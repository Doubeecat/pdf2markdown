# 2025牛客多校7_zh - 竞赛题目

共处理 12 页，提取 10 道题目

---

<!-- 题目 1, 来源页面: 1, 2 -->

## Problem A. 圈圈环礁湖

**Input file:** standard input  
**Output file:** standard output  
**Time limit:** 1 second  
**Memory limit:** 1024 megabytes  

Alice 拥有一批特殊的宝石迷阵玩具，这批玩具由 \( m \) 套独立的部分组成。每套玩具包含 \( k \) 个玩具，每个玩具都是一个 \( n \times n \) 的二维网格。初始状态下，每个玩具都顺序排列如下：

\[
\begin{pmatrix}
1 & 2 & \cdots & n \\
n+1 & n+2 & \cdots & 2n \\
\vdots & \vdots & \ddots & \vdots \\
(n-1)n+1 & (n-1)n+2 & \cdots & n^2
\end{pmatrix}
\]

Alice 对这些玩具进行了 \( 10^6 \) 次操作：等概率均匀随机选择一个玩具的一个 \( 4 \times 4 \) 的子块，顺时针旋转 90 度。例如，

\[
\begin{pmatrix}
1 & 2 & 3 & 4 \\
5 & 6 & 7 & 8 \\
9 & 10 & 11 & 12 \\
13 & 14 & 15 & 16
\end{pmatrix}
\rightarrow
\begin{pmatrix}
13 & 9 & 5 & 1 \\
14 & 10 & 6 & 2 \\
15 & 11 & 7 & 3 \\
16 & 12 & 8 & 4
\end{pmatrix}
\]

Bob 不小心弄坏了 Alice 的 \( k \) 套玩具的全部 \( k \) 个玩具。由于 Bob 不记得弄坏前的具体形状，他按如下方式重新制作了玩具：枚举 \( i \) 从 1 到 \( n^2 \)，等概率随机将 \( i \) 放入一个未填入数字的格子。

Alice 最终发现了这些被动过手脚的玩具。她非常生气，想知道究竟哪几套玩具被 Bob 弄坏了，帮助她判断每一套玩具是否曾被 Bob 重新制作过。请注意，你不需要对每一套玩具都给出正确的判断。

### Input

第一行包含四个整数 \( id, m, k, n \)：其中，\( id \)（\( 0 \leq id < 10 \)）是测试点编号，\( m = 100 \) 表示这批玩具的套装数量，\( k = 10 \) 表示每套玩具的玩具数量，\( n = 10 \) 表示玩具的边长。

接下来是 \( m \) 套玩具的描述，每套玩具包含 \( k \) 个玩具的描述，每个玩具由 \( n \) 行组成，每行包含 \( n \) 个整数，表示该玩具最终的数字排列。

样例可能不符合数据范围，并且样例中有额外的空行，但样例本身不在测试数据中。

### Output

你需要输出一行长度为 \( m \) 的 01 串：如果对应的玩具套装被 Bob 弄坏了，则输出 1，否则输出 0。

请注意，你不需要对每一套玩具都给出正确的判断。在每一个测试点中，如果你的回答中有 90 个是正确的，那么你的回答被认为是正确的。你不需要保证输出的 0 和 1 个数相等。

### Example

**Input:**
```
-1 2 1 4
1 2 3 4
5 6 7 8
9 10 11 12
13 16 14 15

13 9 5 1
14 10 6 2
15 11 7 3
16 12 8 4
```

**Output:**
```
10
```

### Note

样例共有两套玩具，每套共一个，大小为 $4 \times 4$。

第一套玩具一定是 Bob 弄坏的，因为仅通过旋转无法得到这个结果，因此，第二套玩具一定是没弄坏的。

---

<!-- 题目 2, 来源页面: 3, 4 -->

## Problem B. 来自星星的礼物

**Input file:** standard input  
**Output file:** standard output  
**Time limit:** 6 seconds  
**Memory limit:** 1024 megabytes  

Alice 和 Bob 喜欢玩简化版的斗地主游戏：只允许出单牌，并且他们都知道两人的牌。

初始时，Alice 和 Bob 各持有一些牌（共 \( n \) 张），每张牌点数各不相同。对于每一局游戏，两个玩家轮流行动，Alice 先手。在一个玩家的回合中，假设对手上一回合打出的牌点数为 \( x \)，他可以选择两种操作之一：

- 过牌（不打出任何牌）。
- 打出一张点数大于 \( x \) 的牌。

特别地，如果对手没有行动过或上一回合选择过牌，他只能打出任意一张牌，而不能选择过牌。首先出完牌的玩家赢得这局游戏。

在接下来的 \( q \) 天里，Alice 和 Bob 玩了若干局斗地主，每一天都发生了如下两件事情之一：

- 点数为 \( x \) 的手牌的所有者发生了变更。换而言之，如果它当前属于 Alice，那么在这天之后它属于 Bob；否则，在这天之后它属于 Alice。
- 他们想知道，如果只使用两人手中点数在 \( l \) 到 \( r \) 之间的牌进行一局游戏，假设双方都采取最优策略，谁会获胜。特别地，如果这个范围内的牌都属于一个人，则另一个人直接获胜。

帮助他们预测每局游戏的结果。

注意，一局游戏后所有牌回到自己手中。

### Input

第一行包含两个整数 \( n, q \)（\( 1 \leq n, q \leq 5 \times 10^3 \)），表示牌的总数和接下来的天数。

第二行包含一个长度为 \( n \) 仅包含 A 和 B 的字符串 \( s \)，其中 \( s_i = \text{A} \) 表示点数为 \( i \) 的牌初始属于 Alice，否则表示属于 Bob。

接下来 \( q \) 行，第 \( i \) 行包含若干个整数，第一个整数为 \( op_i \)（\( op_i \in \{1, 2\} \)）。

- 若 \( op_i = 1 \)，则第 \( i \) 行还包含一个整数 \( x_i \)（\( 1 \leq x_i \leq n \)），表示第 \( i \) 天点数为 \( x_i \) 的手牌的所有者发生了变更。
- 若 \( op_i = 2 \)，则第 \( i \) 行还包含两个整数 \( l_i, r_i \)（\( 1 \leq l_i \leq r_i \leq n \)），表示询问如果只使用两人手中点数在 \( l_i \) 到 \( r_i \) 之间的牌进行游戏谁会获胜。

保证至少进行了一局游戏。

### Output

对于每个询问，输出一行一个字符串 Alice 或 Bob，表示获胜的玩家。

### Example

**Input:**
```
5 5
ABABA
2 1 3
1 2
2 2 4
1 3
2 1 5
```

**Output:**
```
Alice
Bob
Alice
``` 

---

以上是根据图片内容提取并格式化的 markdown 文本，确保了样例数据的精确性和完整性。

### Example

**Input:**
```
5 5
ABBAB
2 2 2
2 1 5
1 2
2 2 5
2 1 5
```

**Output:**
```
Alice
Alice
Bob
Bob
```

---

<!-- 题目 3, 来源页面: 5 -->

## Problem C. 被遗弃的城市

**Input file:** standard input  
**Output file:** standard output  
**Time limit:** 1 second  
**Memory limit:** 1024 megabytes  

给定一个长度为 \( n \) 的整数序列 \( a \)。你可以执行一个操作：选择 \( a \) 的任意一个子序列，并将该子序列中的每个数字都减去 1。

计算至少需要做多少次操作才能让序列 \( a \) 变为非递减。

子序列指的是将原序列删去任意多个元素后形成的序列。非递减序列指的是对于所有 \( 1 \leq i < n \) 都满足 \( a_i \leq a_{i+1} \) 的序列。

### Input

第一行包含一个整数 \( t \)（\( 1 \leq t \leq 10^4 \)），表示测试用例的个数。

每个测试用例的第一行包含一个整数 \( n \)（\( 1 \leq n \leq 2 \times 10^5 \)）。

下一行包含 \( n \) 个整数 \( a_1, a_2, \ldots, a_n \)（\( 0 \leq a_i \leq 10^9 \)）。

保证所有测试用例中 \( n \) 的总和不超过 \( 2 \times 10^5 \)。

### Output

对于每个测试用例，输出一个整数，即所需的最小操作次数。

### Example

**Input:**
```
3
5
4 2 5 1 3
3
10 8 6
2
7 7
```

**Output:**
```
4
4
0
```

---

<!-- 题目 4, 来源页面: 6 -->

## Problem D. 迷失森林

**Input file:** standard input  
**Output file:** standard output  
**Time limit:** 2 seconds  
**Memory limit:** 1024 megabytes  

给定一个有向图，其中有 \( n \) 个顶点和 \( m \) 条边。请找出从节点 1 到节点 \( n \) 的所有路径中，方差的下确界。

从 1 到 \( n \) 的路径定义为边的序列 \(\{e_1, e_2, \ldots, e_l\}\)，其中 \(e_1\) 的起点是 1，\(e_l\) 的终点是 \(n\)，\(e_i\) 的终点和 \(e_{i+1}\) 的起点相同。注意 \(e_1, e_2, \ldots, e_l\) 是可重的。一条路径 \(p = \{e_1, e_2, \ldots, e_l\}\) 的方差定义为:

\[ D(p) = \frac{1}{l} \sum_{i=1}^{l} (w_{e_i} - \bar{w})^2 \]

其中，\(w_{e_i}\) 是边 \(e_i\) 的权重，\(\bar{w} = \frac{1}{l} \sum_{i=1}^{l} w_{e_i}\) 是路径中所有边 \(e_1, e_2, \ldots, e_l\) 的平均权重。

本题中，下确界的定义在输出格式中给出。

### Input

第一行包含两个整数 \( n \)（\(2 \leq n \leq 30\)）和 \( m \)（\(1 \leq m \leq 200\)）。

接下来的 \( m \) 行中，第 \( i \) 行包含三个整数 \( x_i, y_i, w_i \)（\(1 \leq x_i, y_i \leq n\)，\(x_i \neq y_i\)，\(0 < w_i < 20\)）表示从 \( x_i \) 到 \( y_i \) 有一条权重为 \( w_i \) 的有向边。

### Output

输出一行，包含一个实数，表示从节点 1 到节点 \( n \) 的所有路径中方差的下确界。

如果不存在从节点 1 到节点 \( n \) 的任何路径，请输出 “-1”（不带引号）。

你的答案会被认为是正确的，当且仅当其绝对或相对误差不超过 \(10^{-9}\)。形式化地，假设你的答案是 \(b\)，设 \(\epsilon = \max\{1, b\} \cdot 10^{-9}\)，则你的答案被认为是真的，如果满足以下条件：

- 对于任意从 1 到 \( n \) 的路径 \( p \)，都有 \(D(p) > b - \epsilon\);
- 至少存在一条从 1 到 \( n \) 的路径 \( p_0 \)，使得 \(D(p_0) < b + \epsilon\).

### Example

**Input:**
```
4 4
1 2 3
1 3 4
2 4 5
3 4 7
```

**Output:**
```
1.0000000000000000
```

---

<!-- 题目 5, 来源页面: 7 -->

## Problem E. 弦

**Input file:** standard input  
**Output file:** standard output  
**Time limit:** 2 seconds  
**Memory limit:** 1024 megabytes  

给定一个二进制字符串 $s$（仅由 0 和 1 组成）和一个正整数 $k$，定义一个函数 $f(s, k)$，表示在字符串 $s$ 的末尾添加恰好 $k$ 个字符（只能添加 0 或 1）后，所得到字符串的最长回文子串的长度相对于原始字符串中 $s$ 的最长回文子串长度的最小增加量。

给定一个二进制字符串 $s$ 和一个正整数 $k$，你需要计算并输出 $s$ 的所有非空子串 $s'$ 的 $f(s', k)$ 值之和。定义子串为字符串中的一个非空连续段。

### Input

第一行包含一个整数 $t$（$1 \leq t \leq 10^5$），表示测试用例的数量。

对于每个测试用例，输入一行包含一个二进制字符串 $s$（$1 \leq |s| \leq 5 \times 10^5$）和一个正整数 $k$（$1 \leq k \leq 10^9$），两者之间用一个空格分隔。

所有测试用例的 $|s|$ 之和不超过 $5 \times 10^5$。

### Output

对于每个测试用例，你需要输出一个整数，表示 $s$ 的所有非空子串 $s'$ 的 $f(s', k)$ 值之和。

### Example

**Input:**
```
3
010 1
010 2
0101011101001 100
```

**Output:**
```
2
7
108
```

### Note

在第一个测试用例中，$f(01, 1) = f(10, 1) = 1$，其余为 0。

---

<!-- 题目 6, 来源页面: 8 -->

## Problem F. 相关心

**Input file:** standard input  
**Output file:** standard output  
**Time limit:** 1 second  
**Memory limit:** 1024 megabytes  

给定一个长度为 \( n \) 的整数序列 \( a_1, a_2, \ldots, a_n \)，你可以执行一个操作不超过 \( n \) 次：选择一个整数 \( v \)，然后修改序列中所有数字：\( a_i \) 修改为 \( |a_i - v| \)。

最小化序列中所有不同元素对的差的绝对值之和，即 \( \sum_{1 \le i < j \le n} |a_i - a_j| \)。

由于答案可能很大，输出这个最小值对 \( 998244353 \) 取模的结果。

### Input

第一行包含一个整数 \( n \)（\( 1 \le n \le 2 \times 10^5 \)）。

第二行包含 \( n \) 个整数 \( a_1, a_2, \ldots, a_n \)（\( 0 \le a_i \le 10^9 \)）。

### Output

输出一个整数，最小的 \( \sum_{1 \le i < j \le n} |a_i - a_j| \) 对 \( 998244353 \) 取模的结果。

### Examples

#### Example 1

**Input:**
```
3
5 10 15
```

**Output:**
```
2
```

#### Example 2

**Input:**
```
5
0 0 0 0 1
```

**Output:**
```
4
```

---

<!-- 题目 7, 来源页面: 9 -->

## Problem G. 双生

**Input file:** standard input  
**Output file:** standard output  
**Time limit:** 1 second  
**Memory limit:** 1024 megabytes  

给定一个正偶数 \( n \)。构造一个集合 \(\{1, 2, \ldots, n\}\) 的子集 \( S \)，使其恰好包含 \(\frac{n}{2}\) 个元素，并且对于 \( S \) 中任意三个数 \( x, y, z \)（可能相等），它们的乘积 \( xyz \) 都不是完全平方数。

### Input

第一行包含一个整数 \( t \)（\(1 \leq t \leq 10^4\)），表示测试用例的数量。

对于每个测试用例，输入包含一行一个正偶数 \( n \)（\(2 \leq n \leq 10^6\)）。

保证所有测试用例的 \( n \) 总和不超过 \( 10^6 \)。

### Output

对于每个测试用例，输出一行 \(\frac{n}{2}\) 个用空格分隔的整数，表示构造出的子集 \( S \) 的元素。

### Example

**Input:**
```
3
2
4
6
```

**Output:**
```
2 3
2 3 5
```

---

以上是根据图片内容提取并格式化的 markdown 格式内容。

---

<!-- 题目 8, 来源页面: 10 -->

## Problem H. 逆旅

**Input file:** standard input  
**Output file:** standard output  
**Time limit:** 3 seconds  
**Memory limit:** 1024 megabytes  

注意：此题中 $\text{mex}$ 的定义与常见问题不同。

给定一个长度为 $n$ 的排列 $a_1, a_2, \ldots, a_n$，计算 $a$ 所有子数组的 $\text{mex}$ 之和。

一个非空整数集合 $S$ 的 $\text{mex}$ 是满足以下条件的最小整数 $k$：$k \notin S$ 且 $k > \min(S)$。例如，$\text{mex}(\{1, 3, 5\}) = 2$，$\text{mex}(\{1, 2, 3\}) = 4$。

一个长度为 $n$ 的排列指的是 $1$ 到 $n$ 都恰好出现一次的序列。

### Input

第一行包含一个整数 $t$（$1 \leq t \leq 10^4$），表示测试用例的数量。

对于每个测试用例，第一行包含一个整数 $n$（$1 \leq n \leq 5 \times 10^5$）。

第二行包含 $n$ 个不同的整数 $a_1, a_2, \ldots, a_n$（$1 \leq a_i \leq n$）。

保证所有测试用例的 $n$ 之和不超过 $5 \times 10^6$。

### Output

对于每个测试用例，在一行中输出一个整数，表示所有子数组的 $\text{mex}$ 之和。

### Example

**Input:**
```
3
3
1 2 3
3
2 1 3
10
6 7 5 3 10 1 2 8 4 9
```

**Output:**
```
20
18
259
```

---

<!-- 题目 9, 来源页面: 11 -->

## Problem I. 熔岩层

**Input file:** standard input  
**Output file:** standard output  
**Time limit:** 5 seconds  
**Memory limit:** 1024 megabytes  

给定一个正整数 \( n \) 和一个非空的数码集合 \( D \subset \{1,2,3,4,5,6,7,8,9\} \)。

等概率随机地生成一个长度为 \( 2n-1 \) 的算术表达式。这个表达式的构造遵循以下规则：

- 所有位于奇数位置（从 1 开始计数）的字符，都将是从给定的数码集合 \( D \) 中等概率随机选取的一个数码。
- 所有位于偶数位置（从 1 开始计数）的字符，都将是从 \(\{+,\times,\&,|,\oplus\}\)（加法、乘法、按位与、按位或、按位异或）中等概率随机选取的一个运算符。

例如，如果 \( n=2 \) 且数码集合 \( D=\{1,2\} \)，产生的随机表达式可以是 \(1+1\)，\(2\vee1\) 等等。

计算这个随机生成表达式的值的期望，并将其结果对 \(998244353\) 取模。

注意：所有运算符优先级相同，运算是从左到右依次进行。

### Input

第一行包含一个整数 \( t \)（\(1 \leq t \leq 100\)），表示测试用例的数量。

对于每个测试用例，第一行包含两个整数 \( n,k \)（\(1 \leq n \leq 10^{18}\)，\(1 \leq k \leq 9\)）。

第二行包含 \( k \) 个互不相同的整数，它们是集合 \( D \) 中的元素，每个元素都在 1 到 9 的范围内。

### Output

对于每个测试用例，输出一行一个整数，表示表达式的值的期望对 \(998244353\) 取模后的结果。

可以证明这个期望值一定可以表示为 \(\frac{p}{q}\) 的形式，其中 \( p \) 和 \( q \) 为整数，且存在唯一的整数 \( x \in [0,998244353) \) 使得 \( qx \equiv p \pmod{998244353} \)。你需要输出这个 \( x \) 的值。

### Example

**Input:**
```
3
1 1
5
2 2
1 2
10000 9
1 2 3 4 5 6 7 8 9
```

**Output:**
```
5
463950893
848507702
```

---

<!-- 题目 10, 来源页面: 12 -->

## Problem J. 象牙

**Input file:** standard input  
**Output file:** standard output  
**Time limit:** 5 seconds  
**Memory limit:** 1024 megabytes  

给定四个正整数 \(a, b, c, d\)，计算 \(\gcd(a^b, c^d)\) 的值，并将其对 998244353 取模。

### Input

第一行包含一个整数 \(t\)（\(1 \leq t \leq 10^5\)），表示测试用例的数量。

对于每个测试用例，输入只有一行，包含四个正整数 \(a, b, c, d\)（\(1 \leq a, b, c, d \leq 10^{18}\)）。

### Output

对于每个测试用例，输出一行一个整数，表示 \(\gcd(a^b, c^d)\) 对 998244353 取模后的结果。

### Example

**Input:**
```
5
2 3 3 2
4 2 8 1
6 2 9 1
7 1 11 1
10000000000000 1 10000000000000 1
```

**Output:**
```
1
8
9
1
586315999
1
```

---

